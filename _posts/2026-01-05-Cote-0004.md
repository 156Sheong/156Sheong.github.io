---
layout: single
title:  "코딩 테스트 - 피보나치 수, 프로그래머스 2레벨"
categories: CodingTest
tag: [Programming, TIL, CSharp, CodingTest]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 알고리즘 기초 학습
- 플랫폼 : 프로그래머스
- 단계 : [level 2] 피보나치 수 - 12945
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12945) 


## A. 문서 이력
- 최초 작성일 : 2026-01-05
- 최종 수정일 : 2026-01-05

- 작성 툴 : Typora, Visual Studio Code


## B. 문제 설명
<p>피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. </p>

<p>예를들어 </p>

<ul>
<li>F(2) = F(0) + F(1) = 0 + 1 = 1</li>
<li>F(3) = F(1) + F(2) = 1 + 1 = 2</li>
<li>F(4) = F(2) + F(3) = 1 + 2 = 3</li>
<li>F(5) = F(3) + F(4) = 2 + 3 = 5</li>
</ul>

<p>와 같이 이어집니다.</p>

<p>2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.</p>

<h5>제한 사항</h5>

<ul>
<li>n은 2 이상 100,000 이하인 자연수입니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.</p>


## C. 풀이 과정
1. `int number[0] = 0`, `int number[1] = 1`, ..., `int numbers[n] = numbers[i - 1] + numbers[i - 2]` 으로 피보나치 수열을 만들고, 그 이후에 1234567 를 나눈 나머지를 구함
2. 그러나 전체 케이스 중 절반에서 실패함
3. 프로그래머스에서 실패한 이유를 따로 보여주지는 않았지만, 피보나치 수열의 크기가 너무 커서 에러가 나는 것으로 추측하고 `int` 형식을 `ulong` 형식으로 변경
4. 그러나 실패한 케이스가 줄어들긴 했어도 계속 실패가 나타남
5. '애초에 **100,000 번째 피보나치 수**라는 매우 큰 수를 담을 수 있는 정수 자료형이 있을까?' 하는 의문이 듦
   - 메모리가 허용하는 한, 크기 제약이 없는 `BigInteger` 라는 참조 타입 정수 자료형이 있다는 것은 다른 사람의 풀이를 보고 알았음
6. 문제는 1234567으로 나눈 값을 받아오는 것이기에, `ulong numbers[n]`에 n번째 피보나치 수를 1234567을 나눈 나머지를 저장하는 방향으로 수정
7. 최대 숫자가 1234566 을 넘지 않게 되어 풀이에 성공하고, `int` 형으로도 값을 저장할 수 있게 됨


### Ca. 소스 코드
    ```csharp
    public class Solution {
        public int solution(int n) {
            int answer = 0;
            
            int[] numbers = new int[n + 1];
            numbers[0] = 0;
            numbers[1] = 1;
            
            for(int i = 2; i < n + 1; i++)
            {
                numbers[i] = (numbers[i - 1] + numbers[i - 2]) % 1234567;
            }
            
            answer = numbers[n];
            return answer;
        }
    }
    ```


## D. 결론 및 생각할 점
- 처음으로 풀어본 프로그래머스 레벨 2 수준의 문제
- 레벨 2 수준의 문제도 생각보다 어렵지는 않다고 느꼈음
- 레벨 2 수준의 문제는 자료형이 담을 수 있는 크기나 소요 시간(시간 복잡도) 등도 생각해야 한다는 것을 느꼈음
- 일부 케이스에서만 오류가 나타난다면, 경계 케이스나 문제의 조건을 잘 살펴보면 해답이 보인다고 생각했음