---
layout: single
title:  "객체지향 프로그래밍 학습"
categories: TIL
tag: [Programming, TIL, Computer_Science, Patch]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 객체지향 프로그래밍(OOP, Object-Oriented programming) 학습
- 학습 목표
  - 객체지향 프로그래밍의 개념과 특징을 이해하고 설명할 수 있음

- 주요 키워드
  -  **객체지향 프로그래밍**, **캡슐화**, **상속**, **추상화**, **다형성**, **SOLID 원칙**


## A. 문서 이력
- 최초 작성일 : 2025-12-22
- 최종 수정일 : 2025-12-22

- 작성 툴 : Typora, Visual Studio Code

- 정보 출처 : 경일게임IT아카데미 프로그래밍 4기 - 본과정 11일차 강의 내용, [MSDN 객체지향 기술 개요 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/fundamentals/object-oriented/) 등



## B. 객체지향 프로그래밍 이란?
- 객체 개념을 기반으로 하는 컴퓨터 프로그래밍의 패러다임
- 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보지 않고, **여러 개의 추상화된 독립된 단위(객체)의 모임**으로 보고, 이들의 상호 작용으로 컴퓨터 프로그래밍을 서술하는 방식
- 객체지향 프로그래밍에서 객체는 데이터(필드, 속성)와 기능(메서드)를 가짐
- 객체지향 프로그래밍에서 **클래스**는 특정 데이터와 동작을 가진 객체를 만들기 위해, 이를 정의하는 코드 묶음
- 객체지향 프로그래밍은 일단 만들어 놓으면 코드 분석이 직관적이고, 유지보수나 수정이 쉬워, 지속적인 관리가 필요한 대규모 프로젝트에서 효과적



## C. 객체지향 프로그래밍의 구성 요소
- **클래스(Class)**
  - 같은 종류의 집단에 속하는 속성과 행위를 정의한 틀
- **객체(Object)**
  - 클래스를 가지고 실제로 **인스턴스**(메모리 상에 할당한 것)한 것
  - 객체는 각자의 고유한 속성을 가지고, 클래스에서 정의한 행위를 할 수 있음
- **메서드(Method)**
    - 클래스로부터 생성된 객체를 사용하는 방법으로, 객체에 명령을 내리는 것



## D. 객체지향 프로그래밍의 특징
- **캡슐화 (Encapsulation)**
  - 프로그램 내 객체가 구동되기 위한 데이터(필드, 속성)와 기능(메서드)을 객체 자신이 가질 수 있는 성질
  - 불필요한 데이터의 변질을 막기 위해 내부의 데이터와 동작을 감추고 외부에는 필요한 부분만 노출하도록 할 수 있음(정보 은닉, Information Hiding)
  - 정보 은익을 위해 접근 제한자(Public, Protected, Private)가 사용됨
- **상속 (Inheritance)**
  - 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받은 것
  - 기능 일부분을 수정할 때 자식 클래스에서 상속받은 그 기능만을 수정해 다시 정의하게 됨(오버라이딩, Overridng)
- **추상화 (Abstraction)**
  - 객체의 중요한 부분을 강조하기 위해 공통적인 속성과 기능을 추출하고 불필요한 세부 사항은 제거하여, 객체의 가장 본질적이고 공통적인 부분만을 표현함
- **다형성 (Polymorphism)**
  - 이름과 같이 객체의 속성이나 기능이 상황에 따라 여러 가지 형ㅌ채를 가질 수 있는 성질



## E. 객체지향 프로그래밍의 SOLID 원칙
- **S : 단일 책임 원칙 (SRP, Single Responsibility Principle)**
  - 객체는 단 하나의 책임만 가져야 한다.
  - 하나의 클래스와 그로 만들어진 객체는 하나의 기능을 담당하여, 하나의 책임을 수행하는데 집중되도록 클래스를 개별적으로 설계해야 함
- **O : 개방 폐쇄 원칙 (OCP, Open Closed Priciple)**
  - 객체는 확장에 대해 개방적이고, 수정에 대해서는 폐쇄적이어야 한다.
  - 기능 추가 시 기존의 코드를 수정하는 것은 피해야 한다. (확장이 필요할 때는 새로운 코드를 만들거나, 애초에 확장 가능하게 만들어야 한다.)
- **L : 리스코프 치환 원칙 (LSP, Listov Substitution Priciple)**
  - 자식 객체는 언제나 부모 타입 객체를 교체할 수 있어야 한다.
  - 부모 타입 객체를 자식 타입 객체로 치환해도 정상적으로 동작해야 한다.
- **I : 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)**
  - 하나의 큰 인터페이스보다 용도에 맞는 인터페이스를 잘게 분리해야 한다.
  - 하나의 큰 인터페이스가 있으면 기능 사용 시 이 인터페이스 전체가 불필요하게 사용되고, 수정 시에도 해당 인터페이스를 수정해야하니, 작은 인터페이스 여러 개로 나누는 것이 낫다. 
- **D : 의존성 역전 원칙 (DIP, Dependency Inversion Principle)**
  - 고수준의 모듈은 저수준 모듈의 구현에 의존해선 안된다.
  - 구체화가 많이 진행된 저수준 모듈에 의존하여 고수준 모델을 개발하면, 이를 변경할 때 어려움이 생긴다.



## F. 객체지향 프로그래밍의 주의할 점
- 상황에 따라 객체지향 프로그래밍의 원칙은 지켜지지 않을 수도 있음, 덜어내는 것도 중요함
- 과도한 추상화 및 클래스 분리는 지양해야 함, 수십 개의 클래스와 복잡한 메서드 호출 구조는 개발자에게 인지 부하를 높여 실수를 유발할 수 있음
- 현실의 물리적 제약을 프로그래밍 객체에 그대로 적용하면 유연성이 떨어질 수 있음


<!-- https://lecture.develrocket.com/course/XRP-104030101?content=basic 강의 내용 추가하자 -->