---
layout: single
title:  "CS 기초 학습 - 2(수정 중)"
categories: Programming
tag: [Programming, TIL]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# CS(Computer Science) 기초 학습 - 2
- 학습 목표 : 본격적인 프로그래밍에 앞서, 이진수와 컴퓨터의 언어를 이해하는 것



## A. 문서 이력
- 최초 작성일 : 2025-11-19
- 최종 수정일 : 2025-11-19

- 작성 툴 : Typora, Visual Studio Code

- 정보 출처 : 경일게임IT아카데미 프로그래밍 4기 - 온보딩 캠프 2일차 강의 내용 등



## B. 컴퓨터의 부팅 과정
1. 사용자의 전원 버튼 클릭
2. 전원 클릭을 메인보드가 인식
3. 메인보드가 파워에서 전력을 끌어와 부팅 시작
4. 메인보드 속 CPU가 BIOS(Basic Input Output System)라는 프로그램을 찾아 구동
5. 하드웨어를 초기화함
6. 부트로더 구동
   1) SSD, HDD 같은 보조기억장치로부터 MBR(Master Boot Record)을 읽어 주기억장치인 RAM으로 로드함
   2) CPU는 RAM에 올라간 MBR의 명령어를 수행 시작 + OS 구동을 위한 각종 정보를 보조기억장치에서 RAM으로 로드하기 시작
   3) 각종 드라이버(각종 하드웨어를 작동시키게 도와주는 시스템 소프트웨어)도 보조기억장치에서 RAM으로 로드함
7. OS 작동 시작
8. 사용자가 응용 프로그램을 실행하면 이를 구동하기 위한 정보가 보조기억장치에서 RAM으로 로드함


## B. 컴퓨터가 이해하는 언어
1. 실제 컴퓨터 구동 시에 사용되는 언어는 이진수(0, 1)로 된 기계어
   - 0, 1 인 이유는 스위치를 신호 없음(0) / 신호 있음(1) 으로 구분하기 때문
   - 약한 신호(0.25), 중간 신호(0.5), 강한 신호(0.75) 등이 사이에 없는 이유
     - 2가지 상태인 것이 물리적으로 간단하여 회로를 구현하기 쉽기 때문
     - 신호 손실, 신호 간섭, 잡음 등으로 인한 오류를 최소화할 수 있어, 신뢰성을 확보할 수 있기 때문
     - 논리 회로가 수학적 논리(불 대수)와의 완벽히 대응하여 수학으로 물리적인 하드웨어의 동작을 완벽히 설명하고 예측하며 설계할 수 있기 때문
     - 이미 이진법으로 체계가 잡혔는데, 다른 진법으로 바꾸면 인프라를 모두 다시 만들어야 함(경로의존성)
2. 그러나 사람은 이진수를 이해할 수 없다는 문제가 발생함
3. 따라서 사람은 어셈블리어를 시작으로 점차 고수준 언어로 소스 코드를 작성함
4. 컴퓨터는 사람이 작성한 고수준 언어를 기계어 번역함(컴파일)
5. 컴퓨터는 번역된 기계어를 바탕으로 기능을 수행함


## C. 프로그램의 작동 순서와 주요 구성 요소
![SoureCodeWorking](/images/2025-11-19-CS_Basic02/SoureCodeWorking.png)

<div align="center"><font size="4">
- 소스코드의 작동 방법 이미지 -
</font></div>

- **프로그램 작동 순서**
1. 소스코드가 컴파일러에 의해 오브젝트 코드로 변환
2. 링커는 오브젝트 코드와 필요한 라이브러리 등 추가 파일을 연결해 실행 파일 생성
3. 로더는 실행 파일을 메모리에 적재
4. CPU가 해당 실행 코드를 처리함

- **주요 구성 요소 및 기능**
  - **소스 코드**
    - 개발자가 프로그래밍 언어를 활용해 작성한 원시 코드
    - 사람이 알아보기 쉬운 언어로 구성
    - .cpp , .cs 등의 다양한 언어와 확장자 형식을 지님
  - **컴파일러(Compiler)**
    - 개발자가 작성한 소스 코드(고수준 언어)를 컴퓨터가 이해할 수 있는 오브젝트 코드(기계어 또는 어셈블리어)로 변환
    - 컴파일러가 인간이 작성한 소스 코드를 기계ㅒ어로 번역하는 과정을 `컴파일`이라고 함
    - 오브젝트 코드 : 소스 코드가 컴파일 된 결과물, 실행을 위해 추가적인 처리 필요
  - **링커(Linker)**
    - 여러 개의 오브젝트 코드와 라이브러리(프로그램에 필요한 코드와 데이터 모음)을 하나의 실행 가능한 형태로 결합하는 프로그램
    - 오브젝트 코드에 포함되지 않은 외부 참조를 해결하고, 실행에 필요한 다양한 리소스를 연결함
  - **실팽 파일**
    - 징커를 통해 실행에 필요한 오브젝트 코드와 리소스가 포함된 파일
    - 컴퓨터에서 직접 실행될 수 잇는 형태
    - 윈도우 시스템에선 .exe 확장자를 지님
  - **로더(Loader)**
    - 실행 파일을 보조기억장치에서 메인 메모리에 로드하고, 실행을 위한 환경을 설정함
    - exe 파일을 읽고 실행에 필요한 리소스 할당하고 프로그램 제어 시작
    - 로더에 의해 메모리에 올라간 하나의 단위는 `프로세스`라 불림
      - `프로세스`는 OS의 관리하에 실행되는 독립적 작업 단위
      - 각각의 고유한 메모리 공간, 상태, 자원 등이 할당됨
      - 프로그램이 실행 중인 상태를 나타냄



## D. 이진법과 문자
- 앞서 설명했듯 컴퓨터는 이진수와 이진법을 사용
- 십진법이 한 자리수가 늘어나면 *10이 되듯, 이진법에선 한 자리수가 늘어나면 *2가 됨
- 문자도 `문자 인코딩(Character Encoding)` 과정을 거쳐서 표현 가능함
- ### Da. 변환 방법
  1) **문자열을 숫자로 변환(인코딩)**
    - 사용자가 키보드 등으로 문자를 입력하면 미리 정해 놓은 규칙에 따라 고유한 숫자(코드 포인트)로 변환
    - 이 규칙을 정의한 표나 표준을 `문자 인코딩 스키마`라고 함
  2) **숫자를 이진수로 변환 및 데이터 처리**
    - 문자에서 변환된 십진수가 이진수로 다시 변환되어 처리됨
  3) **이진수를 다시 문자로 변환(디코딩)**
    - 처리된 이진 데이터를 출력하기 위해 인코딩의 역과정을 진행(디코딩)


- ### Db. 주요 문자 인코딩 스키마 표준
  - **ASCII**
    - 7바이트를 사용하여 128개의 문자를 표현한 인코딩
    - 서유럽 언어 등 다른 문자를 추가하기 위해 나머지 1비트를 활용하는 8비트 확장 표준 등장
  - **EUC-KR (Extended Unix Code - Korean)**
    - 한국에서 오랫동안사용된 표준 인코딩 방식 중 하나
    - 한글 완성형 문자(자주 사용되는 2350자)를 2바이트 조합으로 표현
    - 웹과 구형 시스템에서 널리 쓰임
  - **유니코드(Unicode)**
    - 전 세계 거의 모든 문자에 고유한 숫자를 할당한 거대 문자 집합
    - 유니코드 자체는 데이터를 어떻게 저장할지 정의하지 않음
  - **UTF-8**
    - 유니코드를 저장하고 전송하기 위해 가장 널리 사용되는 인코딩 방식
    - 한글과 같은 다국어 문자 표현 가능
    - ASCII 범위의 문자는 1바이트로 표현, 한글이나 다른 복잡한 문자는 2~4바이트로 표현
    - ASCII와 호환
  - **UTF-16**
    - 대부분의 문자를 2바이트(16비트)로 표현하고 일부 문자는 4바이트로 표현
    - 윈도우 OS나 Java플랫폼에서 사용

