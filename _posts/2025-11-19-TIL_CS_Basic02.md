---
layout: single
title:  "CS 기초 학습 - 2"
categories: Programming
tag: [Programming, TIL]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# CS(Computer Science) 기초 학습 - 2
- 학습 목표 : 본격적인 프로그래밍에 앞서, 이진수와 컴퓨터의 언어를 이해하는 것



## A. 문서 이력
- 최초 작성일 : 2025-11-19
- 최종 수정일 : 2025-12-08

- 작성 툴 : Typora, Visual Studio Code

- 정보 출처 : 경일게임IT아카데미 프로그래밍 4기 - 온보딩 캠프 2일차 및 본과정 1일차 강의 내용, [윈도우 Learn - C# 부동 소수점 숫자 형식 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types), [위키백과 - IEEE 754 문서](https://ko.wikipedia.org/wiki/IEEE_754#) 등



## B. 컴퓨터의 부팅 과정
1. 사용자의 전원 버튼 클릭
2. 전원 클릭을 메인보드가 인식
3. 메인보드가 파워에서 전력을 끌어와 부팅 시작
4. 메인보드 속 CPU가 BIOS(Basic Input Output System)라는 프로그램을 찾아 구동
   - 이 때 문제가 생기면 4개의 디버그 LED 중 해당 영역의 LED에 붉은 불빛이 나타남
     - 해당 영역 : CPU / DRAM / 그래픽카드(VGA) / 부팅 장치(BOOT, 보조기억장치 포함)
5. 하드웨어를 초기화함
6. 부트로더 구동
   1) SSD, HDD 같은 보조기억장치로부터 MBR(Master Boot Record)을 읽어 주기억장치인 RAM으로 로드함
   2) CPU는 RAM에 올라간 MBR의 명령어를 수행 시작 + OS 구동을 위한 각종 정보를 보조기억장치에서 RAM으로 로드하기 시작
   3) 각종 드라이버(각종 하드웨어를 작동시키게 도와주는 시스템 소프트웨어)도 보조기억장치에서 RAM으로 로드함
7. OS 작동 시작
8. 사용자가 응용 프로그램을 실행하면 이를 구동하기 위한 정보가 보조기억장치에서 RAM으로 로드함


## B. 컴퓨터가 이해하는 언어
1. 실제 컴퓨터 구동 시에 사용되는 언어는 이진수(0, 1)로 된 기계어
   - 0, 1 인 이유는 스위치를 신호 없음(0) / 신호 있음(1) 으로 구분(비트)하기 때문
     - `비트(bit)`
       - 0과 1로 이루어진, 컴퓨터가 이해할 수 있는 가장 작은 단위
     - `바이트(byte)`
       - 8개의 비트로 이루어진 단위
       - 바이트 단위를 묶어서 킬로바이트, 메가바이트, 기가바이트, 테라바이트 등의 더 높은 단위가 사용됨
   - 약한 신호(0.25), 중간 신호(0.5), 강한 신호(0.75) 등이 사이에 없는 이유
     - 2가지 상태인 것이 물리적으로 간단하여 회로를 구현하기 쉽기 때문
     - 신호 손실, 신호 간섭, 잡음 등으로 인한 오류를 최소화할 수 있어, 신뢰성을 확보할 수 있기 때문
     - 논리 회로가 수학적 논리(불 대수)와의 완벽히 대응하여 수학으로 물리적인 하드웨어의 동작을 완벽히 설명하고 예측하며 설계할 수 있기 때문
     - 이미 이진법으로 체계가 잡혔는데, 다른 진법으로 바꾸면 인프라를 모두 다시 만들어야 함(경로의존성)
2. 그러나 사람은 이진수를 이해할 수 없다는 문제가 발생함
3. 따라서 사람은 어셈블리어를 시작으로 점차 고수준 언어로 소스 코드를 작성함
4. 컴퓨터는 사람이 작성한 고수준 언어를 기계어 번역함(컴파일)
5. 컴퓨터는 번역된 기계어를 바탕으로 기능을 수행함


### Ba. 프로그래밍 언어의 수준
- 프로그래밍 언어의 수준(Level)은 해당 언어가 얼마나 **추상화** 되었는지 의미함
  - 추상화 : 핵심 정보만 나타내고, 세부 정보는 숨겨 단순화한 정도
- 프로그래밍 언어는 크게 **저수준 언어(Low-Level Language)** 와 **고수준 언어(High-Level Language)** 로 분류 가능
- **저수준 언어(Low-Level Language)**
  - **기계어 (Machine Language)**
    - 0과 1로 이루어져 컴퓨터가 직접 해석하는 언어
  - **어셈블리어 (어셈블리어 (Assembly Language))**
    - 기계어에 대응되는 **니모닉(mneumonic) 기호**를 사용한 언어
- **고수준 언어(High-Level Language)**
  - **C++**
    - 언리얼 엔진 게임 개발, 시스템 프로그래밍, 애플리케이션 개발 등에 활용되는 언어
    - 메모리를 직접 관리하고, 상대적으로 복잡한 문법으로 인해 초보자에게 난이도가 높음
  - **C#**
    - 유니티 엔진 게임 개발, 애플리케이션 개발 등에 활용되는 언어
  - **Python**
    - 배우기 쉽고 활용도가 높아 데이터 과학, 웹 개발 등 폭 넓게 사용되는 언어
  - **JavaScript**
    - 웹 개발의 핵심 언어


### Bb. 프로그래밍 패러다임
- 프로그램을 작성한 개발 철학과 관점을 분류
- 프로그래밍 철학에 따라 프로그램 설계 방식이나 스타일이 다름
- 프로그래밍 패러다임을 적절히 선택하면 **코드 가독성**, **유지보수성**, **확장성** 등이 크게 확장됨
- **주요 프로그래밍 패러다임**
  - **명령형 프로그래밍(Imperative Programming)**
    - 컴퓨터에게 어떤 동작을 해야할지 명령어를 순서대로 나열하는 방식
    - 명령형 프로그래밍은 절차적 프로그래밍과 객체지향 프로그래밍으로 나뉨
    - **절차적 프로그래밍(procedural programming)**
      - 순차적 명령어의 흐름(절차)에 집중하는 방식
      - 주요 언어 : C, Pascal
    - **객체지향 프로그래밍(Object-Oriented Programming, OOP)**
      - 객체(데이터와 기능을 묶은 단위)를 중심으로 프로그램을 설계하는 방식
      - 재사용성이 높음
      - 주요 언어 : C++, Java, Python, C#
  - **함수형 프로그래밍(Functional Programming)**
    - 순수 함수들의 조합을 통해 프로그램을 작성하는 방식
    - 상태 변화를 최소하하여 안정성, 재사용성, 병렬성을 확보
    - 주요 언어 : Haskell, Lisp


## C. 프로그램의 작동 순서와 주요 구성 요소
![SoureCodeWorking](/images/2025-11-19-CS_Basic02/SoureCodeWorking.png)

<div align="center"><font size="4">
- 소스코드의 작동 방법 이미지 -
</font></div>

- **프로그램 작동 순서**
1. 소스코드가 컴파일러에 의해 오브젝트 코드로 변환
2. 링커는 오브젝트 코드와 필요한 라이브러리 등 추가 파일을 연결해 실행 파일 생성
3. 로더는 실행 파일을 메모리에 적재
4. CPU가 해당 실행 코드를 처리함

- **주요 구성 요소 및 기능**
  - **소스 코드**
    - 개발자가 프로그래밍 언어를 활용해 작성한 원시 코드
    - 사람이 알아보기 쉬운 언어로 구성
    - .cpp, .cs 등의 다양한 언어와 확장자 형식을 지님
  - **컴파일러(Compiler)**
    - 개발자가 작성한 소스 코드(고수준 언어)를 컴퓨터가 이해할 수 있는 오브젝트 코드(기계어 또는 어셈블리어)로 변환
    - 컴파일러가 인간이 작성한 소스 코드를 기계어로 번역하는 과정을 `컴파일`이라고 함
    - `오브젝트 코드`
      - 소스 코드가 컴파일 된 결과물, 실행을 위해 추가적인 처리 필요
  - **링커(Linker)**
    - 여러 개의 오브젝트 코드와 라이브러리(프로그램에 필요한 코드와 데이터 모음)을 하나의 실행 가능한 형태로 결합하는 프로그램
    - 오브젝트 코드에 포함되지 않은 외부 참조를 해결하고, 실행에 필요한 다양한 리소스를 연결함
  - **실팽 파일**
    - 징커를 통해 실행에 필요한 오브젝트 코드와 리소스가 포함된 파일
    - 컴퓨터에서 직접 실행될 수 잇는 형태
    - 윈도우 시스템에선 .exe 확장자를 지님
  - **로더(Loader)**
    - 실행 파일을 보조기억장치에서 메인 메모리에 로드하고, 실행을 위한 환경을 설정함
    - exe 파일을 읽고 실행에 필요한 리소스 할당하고 프로그램 제어 시작
    - 로더에 의해 메모리에 올라간 하나의 단위는 `프로세스`라 불림
      - `프로세스`
        - OS의 관리하에 실행되는 독립적 작업 단위
        - 프로그램이 실행 중인 상태를 나타냄
        - 각각의 프로세스는 고유한 메모리 공간, 상태, 자원 등이 할당됨



## D. 이진법과 문자
- 앞서 설명했듯 컴퓨터는 이진수와 이진법을 사용
- 십진법이 한 자리수가 늘어나면 *10이 되듯, 이진법에선 한 자리수가 늘어나면 *2가 됨
- 문자도 `문자 인코딩(Character Encoding)` 과정을 거쳐서 표현 가능함
- ### Da. 변환 방법
  1) **문자열을 숫자로 변환(인코딩)**
    - 사용자가 키보드 등으로 문자를 입력하면 미리 정해 놓은 규칙에 따라 고유한 숫자(코드 포인트)로 변환
    - 이 규칙을 정의한 표나 표준을 `문자 인코딩 스키마`라고 함
  2) **숫자를 이진수로 변환 및 데이터 처리**
    - 문자에서 변환된 십진수가 이진수로 다시 변환되어 처리됨
  3) **이진수를 다시 문자로 변환(디코딩)**
    - 처리된 이진 데이터를 출력하기 위해 인코딩의 역과정을 진행(디코딩)


- ### Db. 주요 문자 인코딩 스키마 표준
  - **ASCII**
    - 7바이트를 사용하여 128개의 문자를 표현한 인코딩
    - 서유럽 언어 등 다른 문자를 추가하기 위해 나머지 1비트를 활용하는 8비트 확장 표준 등장
  - **EUC-KR (Extended Unix Code - Korean)**
    - 한국에서 오랫동안사용된 표준 인코딩 방식 중 하나
    - 한글 완성형 문자(자주 사용되는 2350자)를 2바이트 조합으로 표현
    - 웹과 구형 시스템에서 널리 쓰임
  - **유니코드(Unicode)**
    - 전 세계 거의 모든 문자에 고유한 숫자를 할당한 거대 문자 집합
    - 유니코드 자체는 데이터를 어떻게 저장할지 정의하지 않음
  - **UTF-8**
    - 유니코드를 저장하고 전송하기 위해 가장 널리 사용되는 인코딩 방식
    - 한글과 같은 다국어 문자 표현 가능
    - ASCII 범위의 문자는 1바이트로 표현, 한글이나 다른 복잡한 문자는 2~4바이트로 표현
    - ASCII와 호환
  - **UTF-16**
    - 대부분의 문자를 2바이트(16비트)로 표현하고 일부 문자는 4바이트로 표현
    - 윈도우 OS나 Java플랫폼에서 사용



## E. 이진법과 소수 표현
- 아래 코드에서 True가 출력되지 않는다. 왜 그런지 알아보자.
```csharp
double a = 0.1 + 0.2;
double b = 0.3;

Console.WriteLine(a == b);  // False 출력
```
- **진법과 분수 및 소수의 표현**
  - 진법 표현에서 상대적으로 자유로운 분수와는 다르게, 십진법의 소수는 십진법으로 표현할 수 있는 숫자만 정확히 표현할 수 있다.
  - 예를 들어, 분수 1/3은 십진법에서 0.333333333... 과 같은 무한소수로 표현해야 한다.
  - 여기에 표현할 수 있는 자리수에 제한이 있다면, 그 아래 자리수의 정밀도에서는 정밀도가 떨어질 것이다.
- **컴퓨터의 소수 표현**
  - 이진법을 사용해서 숫자를 표현하는 컴퓨터도 마찬가지이다.
  - 컴퓨터가 보여주는 소수는 이진법으로 만들어진 숫자를 십진법으로 변환하여 표기하는 것이다.
  - 예를 들어, C#에서 소수를 표현할 수 있는 실수형 키워드인 float, double 모두 부호, 지수, 가수를 활용한 이진법으로 만들어진 소수를 십진법으로 표현한다.
  - 10^-1 인 0.1을, 2^-1, 2^-2, 2^-3 ... 등과 같은 이진법의 소수와, 소수점이 어디인지 찍어주는 지수를 결합하여 표현해야 하는 것이다.
  - 그 원리상 0.5, 0.25, 0.125 등과 같이 분모가 2의 몇 승으로 표현될 수 있는 값은 정확히 표시할 수 있지만, 그 이외의 수에는 오차가 발생한다.
  - 게다가 float과 double은 각각 32비트, 64비트의 메모리 제한이 있고, 이 중 23비트와 52비트만 명시적으로 가수에 포함되니, 소수점 아래 자리수가 더 많아질수록 오차는 더욱 커질 것이다.
  - 그러니 결과적으로, 0.1f, 0.2f 는 매우 작은 소수점에서 오차가 발생하고, 이 때문에 둘을 더해도 0.3f과 같지는 않을 것이다.
- **대안적으로 사용할 수 있는 방법**
  - 이에 대한 대안으로 사용할 수 있는 방법은 상황에 따라 몇 가지가 있을 수 있다.
  - 대안 1
    - 소수점의 자리수가 몇까지 이어질 것인지 알고 있다면, 그만큼 10의 배수로 곱한 다음 int 값으로 만들어 bool 계산을 하는 방법이다.
    - 예를 들어, *10을 한 다음, int 자료형으로 변환해 1 + 2와 3을 비교하는 것이다.
  - 대안 2
    - a와 b의 값을 비교하는 것이 목적이라면, 매우 작은 오차는 동일하게 보는 방법도 있을 것이다.
    - 예를 들어, double 자료형 1 + 2 >= 2.99 && 1 + 2 < 3.01 처럼 범위를 넣는다면 작은 오차는 동일하게 볼 수 있을 것이다.
  - 대안 3
    - 이진법 대신 십진법의 부동소수점을 사용하는 decimal 자료형을 사용하면 될 것 같다.
    - 예를 들어, decimal 자료형으로 0.1m + 0.2m == 0.3m 을 비교하면 bool 자료형의 true 값을 건넨다.



## F. 더 생각해보기
- 양자 컴퓨터도 이진법을 사용할까? 만약 아니라면 어떤 진법을 사용하고, 왜 그 진법을 사용할까?
  - (힌트 : Q# 언어)