---
layout: single
title:  "코딩 테스트 - 하샤드 수, 프로그래머스 1레벨"
categories: Coding_Test
tag: [Programming, TIL, CSharp, Coding_Test]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 알고리즘 기초 학습
- 플랫폼 : 프로그래머스
- 단계 : [level 1] 하샤드 수 - 12947 
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12947?language=csharp) 


## A. 문서 이력
- 최초 작성일 : 2026-01-02
- 최종 수정일 : 2026-01-02

- 작성 툴 : Typora, Visual Studio Code


## B. 문제 설명
<p>양의 정수 <code>x</code>가 하샤드 수이려면 <code>x</code>의 자릿수의 합으로 <code>x</code>가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 <code>x</code>를 입력받아 <code>x</code>가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.</p>

<h5>제한 조건</h5>

<ul>
<li><code>x</code>는 1 이상, 10000 이하인 정수입니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>x</th>
<th style="text-align: center">return</th>
</tr>
</thead>
        <tbody><tr>
<td>10</td>
<td style="text-align: center">true</td>
</tr>
<tr>
<td>12</td>
<td style="text-align: center">true</td>
</tr>
<tr>
<td>11</td>
<td style="text-align: center">false</td>
</tr>
<tr>
<td>13</td>
<td style="text-align: center">false</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p><strong>입출력 예 #1</strong><br>
10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.</p>

<p><strong>입출력 예 #2</strong><br>
12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.</p>

<p><strong>입출력 예 #3</strong><br>
11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.</p>

<p><strong>입출력 예 #4</strong><br>
13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.</p>

<hr>

<p>※ 공지 - 2023년 5월 27일 문제 지문 오탈자 수정되었습니다.</p>


## C. 풀이 과정
- 2가지 서로 다른 방법을 사용하여 풀이할 수 있을 것 같음
  - 방법 1 : 최대 5회 자리 수 만큼 10으로 나누고 그 때마다 나머지를 int 배열로 저장한 뒤, int 배열을 모두 더하기
  - 방법 2 : 숫자를 string으로 받아서 char 배열로 변환한 다음, 다시 숫자로 변환해 다 더하기

- 방법 1, 방법 2 모두 사용해서 걸린 시간, 코드 길이, 사용 메모리, 연산 시간 등 비교해보자


### Ca. 방법 1-1
- 최초로 풀었던 방법
- 방법 1-1을 한 다음 개선 방안이 생각나 1-2도 시도했음
- 성능 요약 : 메모리: 31.2 MB, 시간: 0.82 ms
- 소스 코드
  ```csharp
    public static class Sol01
    {
        // 방법 1-1 : 최대 5회 자리 수 만큼 10으로 나누고 그 때마다 나머지를 int 배열로 저장한 뒤, int 배열을 모두 더하기 ()
        public static bool Solution01(int x)
        {
            List<int> numlist = new List<int>();
            int tempNumber = x; // 원본인 int x 는 나누기를 할 때 사용해야해서 숫자를 값 복사한 후에 사용
            int listNumber = 0;
            int finalNumber = 0;    // `using System.Linq;`를 사용 안할 시 최종 계산을 위해 필요한 변수

            // tempNumber가 일의 자리가 될 때까지 10으로 나눗셈을 반복하고, 나머지는 numlist[listNumber] 에 저장
            while (tempNumber >= 10)
            {
                numlist.Add(tempNumber % 10);
                tempNumber /= 10;
                listNumber++;
            }

            // 마지막 일즤 자리 숫자도 numlist[listNumber]에 저장
            numlist.Add(tempNumber);

            // 리스트의 내용을 모두 더하고, 원본 x 와 나눌 시 0이 되는지 여부를 return
            for (int i = 0; i < numlist.Count; i++)
            {
                finalNumber += numlist[i];
            }

            return x % finalNumber == 0;
            // return x % numlist.Sum() == 0;   // VS C# 10.0에선 작동했는데 프로그래머스에선 작동 안됨, 프로그래머스에선 `using System.Linq;` 필요
        }
    }   
  ```


  ### Cb. 방법 1-2
- 최초로 풀었던 방법에서 수정한 방법
- 없앨 수 있어보이는 변수의 개수를 줄여서 연산에 필요한 시간을 줄임
- 첫 예상과 다르게 필요한 메모리는 큰 차이 없었음
- 성능 요약 : 메모리: 31.1 MB, 시간: 0.23 ms
- 소스 코드
  ```csharp
    public static class Sol011
    {
        // 방법 1-2 : 최대 5회 자리 수 만큼 10으로 나누고 그 때마다 나머지를 int 배열로 저장한 뒤, int 배열을 모두 더하기
        // 1-1 에서 꼭 필요하지 않은 변수 제외한 버젼
        public static bool Solution011(int x)
        {
            int tempNumber = x; // 원본인 int x 는 나누기를 할 때 사용해야해서 숫자를 값 복사한 후에 사용
            int finalNumber = 0;    // 프로그래머스에선 필요한 변수

            // tempNumber가 일의 자리가 될 때까지 10으로 나눗셈을 반복하고, 나머지는 finalNumber에 누적
            while (tempNumber >= 10)
            {
                finalNumber += tempNumber % 10;
                tempNumber /= 10;
            }
            finalNumber += tempNumber;
            return x % finalNumber == 0;
        }
    }
  ```


### Cc. 방법 2
- 마지막으로 시도한 방법
- 소스 코드의 길이는 **방법 1-2** 에 비해 1줄 줄었으나, 메모리와 시간이 가장 많이 든 방법
- int -> string -> char[] -> string -> int 로 형변환에 시간이 오래 걸리는 것 같음
- 성능 요약 : 메모리: 31.3 MB, 시간: 0.86 ms
- 소스 코드
  ```csharp
    public static class Sol02
    {
        // 방법 2 : 숫자를 string으로 받아서 char 배열로 변환한 다음, 다시 숫자로 변환해 다 더하기
        public static bool Solution02(int x)
        {
            string numword = x.ToString();  // 숫자를 string으로 변경
            char[] chars = numword.ToCharArray();   // string을 다시 char[] 로 변경
            int finalNumber = 0;

            // char[] 를 string화 시킨 후, 다시 int화 시켜서 finalNumber 저장하는 것을 반복
            for (int i = 0; i < chars.Length; i++)
            {
                finalNumber += int.Parse(chars[i].ToString());
            }
            return x % finalNumber == 0;
        }
    }
  ```


## D. 결론 및 생각할 점
- 세 가지 방법 모두 각자 1시간 미만 소요 
- 풀이 방법 모색 & 소스 코드 사용 과정에서 막히는 부분이 없었음
- 프로그래머스 1레벨 문제 중에선 가장 쉬운 편에 속하는 것으로 보임
- 변수의 개수가 적고, 계산 및 형변환이 적은 소스 코드가 가장 빠른 것 같음