---
layout: single
title:  "클래스 학습"
categories: TIL
tag: [Programming, TIL, Collaboration]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 클래스(Class) 학습
- 학습 목표
  - **클래스**의 개념과 특징을 이해하고 설명할 수 있음
  - 클래스에서 사용되는 **인스턴스**, **접근 한정자**, **프로퍼티** 등에 대해 이해하고 설명할 수 있음
  - 클래스를 직접 사용하여 원하는 객체를 생성하고 제어 및 수정할 수 있음

- 주요 키워드
  -  **클래스**, **인스턴스**, **프로퍼티**



## A. 문서 이력
- 최초 작성일 : 2025-12-22
- 최종 수정일 : 2025-01-08

- 작성 툴 : Typora, Visual Studio Code

- 정보 출처 : 경일게임IT아카데미 프로그래밍 4기 - 본과정 11, 12일차 강의 내용, [MSDN 클래스 소개 문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/fundamentals/types/classes) 등



## B. 클래스(Class)란?
- 객체지향 프로그래밍에서 객체를 만들기 위한 설계도
- 데이터(필드, 속성)와 기능(메서드)을 하나로 묶어 정의하는 틀



## C. 클래스의 주요 구성 요소 및 특징
### Ca. 클래스의 주요 구성 요소
- **클래스**
  - 객체를 만들기 위한 설계도
  - `class` 키워드를 사용하여 정의
  - 클래스 명칭은 파스칼 케이스로 작명
- **필드 및 속성**
  - 객체의 데이터를 저장
  - 필드는 집적 접근하는 변수이고, 속성은 필드의 접근을 제어하는 게이트(`get`, `set`) 역할
- **메서드**
  - 객체가 수행할 수 있는 기능을 정의하는 함수
- **생성자**
  - 클래스 이름과 같고, `new` 키워드를 통해 객체를 생성할 때 호출되어 필드 초기화 등을 담당
- **객체 및 인스턴스**
  - 클래스를 바탕으로 메모리에 실체화된 객체



### Cb. 클래스의 주요 특징
- 클래스는 객체지향 프로그래밍의 네 가지 주요 기둥인 캡슐화, 상속, 추상화, 다형성을 구현하는 기본 단위
- 일반적으로 C#에서 파일 관리는 클래스 하나 당 파일 하나로 관리함

- 클래스도 구조체처럼 생성자를 지원함
- 클래스는 구조체와 다르게 참조 타입이라 객체가 생성될 때 힙 메모리에 할당되고, 변수는 객체가 저장된 메모리 주소(참조) 가 저장됨

- `public`, `private`, `protected`, `internal` 등의 **접근 한정자**를 사용하여 클래스 및 해당 멤버의 가시성 제어 가능
- 클래스 내의 필드에 접근 한정자를 사용하지 않으면 내부적으로 `private` 으로 선언됨

- 클래스를 통해 관련 데이터와 함수를 그룹화하여 코드를 모듈화하고 재사용 가능한 형태로 만들 수 있음
- 다른 클래스로부터 상속받아 기능을 확장하거나 특화 가능





### D. 클래스와 프로퍼티(Property)
- C# 기능 중엔 클래스와 구조체에서 사용 가능한 프로퍼티가 존재함
- 프로퍼티는 클래스나 구조체 내부의 private 멤버 변수에 안전하게 접근하고 값을 읽거나(`get`) 설정(`set`)할 수 있도록 돕는 특수한 메서드 쌍을 의미(은닉성을 지원)
- 프로퍼티는 변수처럼 선언되어 있지만, 내부에 getter, setter 가 있는 함수
- C# 에선 `{ get; set; }` 형태의 자동 구현 프로퍼티도 존재함
  - 명시적으로 클래스 내 변수를 선언하지 않아도, 자동으로 메모리에 관련 변수가 할당되고 사용할 수 있게 해줌
- 프로퍼티 사용 시 IDE에서 값이 변경된 로그 추적도 용이함
- 프로퍼티 사용 예시
  ```csharp
    public class ClassStudy
    {
        private int _playerId = 5;


        // getter, setter 함수를 직접 구현하는 방법
        public int GetPlayerId() { return _playerId; }  // getter
        public void SetPlayerId(int value) { _playerId = value; }  // setter


        // 프로퍼티
        public int PlayerId // 변수처럼 선언되어 있지만, 내부에 getter, setter 가 있는 함수임
        {
            get // 접근 한정자 사용할 수도 있으나, 값을 읽는 것이기 때문에 매우 드묾
            {
                return _playerId;
            }
            set // private, protected 등의 접근 한정자를 사용하여 특정 위치에서만 사용 가능하게 만들 수 있음
            {
                Console.WriteLine($"현재 값 : {value}");   // 값 변경을 추척하는 콘솔 로그를 남길 수 있음
                _playerId = value;
            }
        }

        // 자동 구현 프로퍼티
        public float MoveSpeed { get; set; }
    }

    // 앞서 선언한 캐릭터 클래스를 다른 클래스에서 불러와 사용 가능
    internal class Program
    {
        static void Main(string[] args)
        {
            ClassStudy study = new();

            study.PlayerId = 15;    // 클래스의 프로퍼티 setter 호출, 값 변경 시 원본도 변경됨
            Console.WriteLine(study.PlayerId);  // 클래스의 프로퍼티 getter 호출
        }
    }
  ```



### E. 클래스와 사용자 정의 자료형
- 클래스도 구조체처럼 사용자 정의 자료형으로 사용할 수 있음
- 사용 예시
  ```csharp
    // 부모 클래스 선언부
    public class Character
    {
        public int HP { get; private set; }
        public float MoveSpeed { get; private set; } = 3.2f;

        // 클래스의 생성자
        public Character(int hp)
        {
            HP = hp;
            Console.WriteLine("생성자 호출 확인");
        }


        // 클래스의 소멸자 (거의 사용 안함)
        ~Character()
        {

        }

        public void Move()
        {
            // 이동 기능 구현 메서드
        }

        public void TakeDamage(int damage)
        {
            // 피해를 받는 기능 구현 메서드
            HP -= damage;
            Console.WriteLine($"피해량 : {damage}, 남은 생명력 {HP}");
        }
    }

    // 자식 클래스 선언부
    public class Monster : Character
    {
        public Monster(int hp) : base(hp)
        {
            // 생략
        }
    }

    // 앞서 선언한 클래스 사용
    internal class Program
    {
        static void Main(string[] args)
        {
            // 인스턴스의 메모리 주소  // 인스턴스
            Character player             = new Character(100);

            player.TakeDamage(15);
            player.Move();
        }
    }
  ```