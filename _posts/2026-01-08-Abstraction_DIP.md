---
layout: single
title:  "더미 포스트"
categories: TIL
tag: [Programming, TIL, WIP]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 객체 지향의 특성 - 추상화 및 의존성 역전 원칙



## A. 추상화 (Abstraction)
- **불필요한 구현 세부 사항을 숨기고**, 사용자에게 **핵심적인 속성과 동작을 간추려** 표현하는 것
   - 추가로 필요한 속성이나 동작이 있다면, 추상화를 상속받은 객체에서 구현함
   - 복잡한 내부를 숨겨도, 그 내부의 입구로 접근할 수 있는 기능을 넣어서, 사용자는 상대적으로 단순하게 일 처리가 가능
- 추상화는 의존성 역전 원칙과 연결되는 개념
- C#에서는 인터페이스, 추상 클래스를 통해 구현됨



## B. 의존성 역전 원칙 (DIP, Dependency Inversion Principle)
- 소프트웨어 모듈을 분리하는 형식
- 클래스가 다른 클래스와 관계 되어 있어서 다른 클래스의 작동 방식을 최대한 적게 알아야 함(결합 낮게 유지해야)
   - 클래스 사이의 연결이 단순하지 않고 복잡해지면, 코드를 읽고 해석하기 어려워짐
   - 만약 클래스가 다른 클래스의 작동 방식을 많이 알고 있다면, 한 기능을 수정할 때 같이 수정해야할 부분이 많아지는 등의 어려움 생길 것
- 상위 레벨 모듈과 하위 레벨 모듈이 모두 추상화에 의존해야 함
   - 상위 레벨 모듈과 하위 레벨 모듈 모두 반대측의 속성과 동작을 직접 가져오면 안됨



## C. 추상화와 의존성 역전 원칙의 예시
### Ca. 가정 
1. 만약에 당신이 미래를 배경 *세 종족이 자원을 두고 전쟁을 벌이는 게임*을 만든다고 가정해보자.
2. 당신의 역할은 이 게임에서 사용할 건물을 만드는 것이다.
3. 그런데 이 전쟁 게임의 건물 다음의 4가지 유형으로 나뉜다고 해보자.
   - 유닛을 생산하는 **생산 건물**
   - 본진을 방어하는 **방어 건물**
   - 병력의 최대 규모를 늘려주는 **보급 건물**
   - 세력을 발전시키는 **업그레이드 건물**
4. 각 건물은 공통적으로 필요한 부분도 있지만, 아래와 같이 건물 유형에 따라 각자 따로 구현할 부분도 있을 것이다.
   - 각 건물은 공통적으로 유저에 의해 **선택**되거나, 파괴가 가능하기에 **생명력**을 지님
   - 생산 선물은 **생산 기능**, 방어 건물은 **공격 기능**, 보급 건물은 **인구수 향상**, 업그레이드 건물은 **업그레이드** 기능이 따로 있음
5. 그리고 각 종족마다 **유닛, 공격, 업그레이드 등이 서로 다르다.**


### Cb. 구현 
1. 그러면 이는 추상화와 의존성 역전 원칙에 따라 공통적인 부분은 추상화하여 부모 클래스로 남겨야 한다.
   - **생명력** 속성은 추상화에 남아야 함
   - 유저에 **선택** 되는 기능은 추상화에 남겨야 함
2. 그리고 세부 사항은 구현부인 자식 클래스로 보내야 한다.
   - 생산 선물은 **생산 기능**, 방어 건물은 **공격 기능**, 보급 건물은 **인구수 향상**, 업그레이드 건물은 **업그레이드** 기능 등


### Cc. 세부 구현
1. 그런데 여기서 아래와 같은 추가 조건이 생긴다면 어떨까?
   - 생산 건물이 각 종족 당 평균 3개
   - 각 생산 건물이 생산하는 유닛의 종류가 다름
   - 생산하는 유닛 중엔 특정 건물이 있어야 해금되는 종류가 있음
2. 여기서 생각해야 하는 건 추상화 - 구현 의 관계가 상대적이라는 것이다.
3. 상속을 5번, 10번 이런 식으로 많이 받는 건 코드가 복잡해지겠지만, 부모 - 자식 - 손자 정도의 3대 클래스 상속 정도는 문제가 없을 것이다.
4. 그러니 여기서도 다시 추상화와 의존성 역전 원칙에 따라 나눠보자.
  (이후로는 추후 업데이트 예정)


## D. 관련 코드
### Da. 위의 게임 개발 예시 
```csharp
  // 어떻게 구현하지? 추상 클래스와 인터페이스를 잘 못다뤄서 고민이 필요

``` 


### Db. 잘 안된 예시 
```csharp
  // 어떻게 구현하지? 추상 클래스와 인터페이스를 잘 못다뤄서 고민이 필요

``` 



## E. 그 외 기타 사항
- 추상화와 의존성 역전 원칙의 구현 방법은 언어마다 다를 수 있음
  - C++ 는 여러 부모 클래스로부터 상속 받을 수 있음
  - 그러나 C# 은 이를 위해선 인터페이스를 사용해야 함
- 언제나 추상화와 의존성 역전 원칙이 경제성이 있지는 않음
  - 프로젝트의 규모가 커지고, 지속적으로 유지보수가 필요할 때 이와 같은 OOP 가 더 잘 지킬수록 경제성이 생김
  - 반대로 프로젝트 규모가 작고, 유지보수가 필요 없다면 OOP의 여러 원칙을 꼭 지킬 필요는 없음



## F. 참고 자료
- [유니티 디자인패턴 1부](https://www.youtube.com/live/iyeRmq24HVk?si=FZdNdV5tCID1k--j)
- [MSDN 아키텍처 원칙](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles)
- [위키독스 소프트웨어개발 입문 - 추상화 문서](https://wikidocs.net/274929#:~:text=%EC%B6%94%EC%83%81%ED%99%94%EC%9D%98%20%EC%9E%A5%EC%A0%90,%EB%AF%B8%EC%B9%98%EB%8A%94%20%EC%98%81%ED%96%A5%EC%9D%84%20%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%9C%EB%8B%A4.)
