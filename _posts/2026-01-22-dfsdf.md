



코루틴과 유니티 이벤트
업데이트는 아닌데, 내가 필요할 때 업데이트 처럼 사용 가능

yield 키워드가 핵심

StartCoroutine 으로 시작


yield return - 실행되다 yield return 만나면 유니티에 제어권을 반납하여, 일시 정지 상태가 됨
  yield return null
  yield return new WaitForSeconds(시간(초)) // 1초 동안 일시 정지, class 객체라 new 붙여야 함
  yield return new WaitForFixedUpdate()
  yield return new WaitForEndOfFrame()
  yield return new WaitUntil()  // 특정 조건 true 가 될 때까지 대기
  yield return new WaitWhile()
  yield return new WaitForSecondsRealtime()
  


 yield break



코루틴을 변수에 담아 사용
  코루틴은 유니티 내부적으로는 동기 방식이지만 yield 를 활용해 비동기 방식처럼 사용 가능
  코루틴은 클래스
  코루틴을 실행하면 클래스 객체가 생성
  힙 메모리에 클래스 인스턴스가 할당
  주기적으로 실행되어야 하는 코루틴의 경우 변수를 선언해 미리 힙에 할당해놓고, 해당 변수에 생성되는 코루틴 객체를 할당하는 방식을 사용한다면 메모리 공간을 절약하며 사용할 수 있기 때문에 메모리 단편화를 방지
  
StartCoroutine 반환형은 Coroutaine 클래스

사용이 끝나면 반드시 중지할 것 (stopCorutine)
  코루틴을 실행하면 클래스 객체가 생성되며 메모리가 할당
  별도로 해제하지 않는 상태로 반복/누적이 될 경우, 메모리 누수가 발생 가능





  옵져버 패턴





  유니티 이벤트도 있음




  유니티 액션 -> 사실상 델리게이트임, 그냥 Action 써도 됨