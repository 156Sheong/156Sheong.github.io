---
layout: single
title:  "코딩 테스트 - 최대공약수와 최소공배수"
categories: CodingTest
tag: [Programming, TIL, CSharp, CodingTest]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

# 알고리즘 기초 학습
- 플랫폼 : 프로그래머스
- 단계 : [level 1] 최대공약수와 최소공배수 - 12940 
- [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12940) 


## A. 문서 이력
- 최초 작성일 : 2026-01-16
- 최종 수정일 : 2026-01-16

- 작성 툴 : Typora, Visual Studio Code


## B. 문제 설명
<p>두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.</p>

<h5>제한 사항</h5>

<ul>
<li>두 수는 1이상 1000000이하의 자연수입니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>n</th>
<th>m</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>12</td>
<td>[3, 12]</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>[1, 10]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
위의 설명과 같습니다.</p>

<p>입출력 예 #2<br>
자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다.</p>


## C. 풀이 과정
- 최대공약수는 유클리드 호제법을 사용
  - 나누기 나머지 대신 두 수를 0이 남을 때 까지 서로 계속 빼는 것도 방법
- 최소공배수는 {두 수의 곱} = {최대공약수} × {최소공배수} 인 것을 활용


### Ca. 소스 코드
- 첫 번째 통과 시 소스 코드
  - 메모리: 31.5 MB, 시간: 0.25 ms
  ```csharp
    public class Solution 
    {
        // 최대공약수는 유클리드 호제법을 사용
        // 최소공배수는 {두 수의 곱} = {최대공약수} × {최소공배수} 인 것을 활용
        public int[] solution(int n, int m) 
        {
            int[] answer = new int[2];

            if (m > n) answer[0] = MaxCal(m, n);
            else answer[0] = MaxCal(n, m);

            answer[1] = n * m / answer[0];

            return answer;
        }
        
        // 유클리드 호제법을 사용하에 최대공약수를 구하는 함수
        public int MaxCal(int a, int b)
        {
            while (a % b != 0)
            {
                int temp = a % b;
                a = b;
                b = temp;
            }

            return b;
        }
    }

  ```

## D. 결론 및 생각할 점
- 최대공약수와 최소공배수를 구하는 방법을 몰라서 인터넷을 검색해 봄
- 이러한 종류의 문제는 방법을 모르면 풀지 못하니, **카탈랑 수열**처럼 풀이 방법을 외워야 할 것 같다는 생각을 함