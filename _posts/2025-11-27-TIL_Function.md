---
layout: single
title:  "함수 학습"
categories: Programming
tag: [Programming, TIL, CSharp]
toc: true
sidebar:
    nav: "counts"
typora-root-url: ../
---



# 함수(Function) 학습
- 학습 목표 : C#에서 활용 가능한 함수 학습



## A. 문서 이력
- 최초 작성일 : 2025-11-27
- 최종 수정일 : 2025-12-03

- 작성 툴 : Typora, Visual Studio Code

- 정보 출처 : 경일게임IT아카데미 프로그래밍 4기 - 온보딩 캠프 9일차 강의 내용, [마이크로소프트 Learn 매서드 매개변수 및 한정자 설명](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/method-parameters) 등



## B. 함수의 정의
- 함수는 특정 작업을 수행하도록 미리 만들어둔 코드의 집합(코드 블록)



## C. 함수의 특징
- 재사용성(Reusability)
  - 한 번 정의된 코드를 프로그램의 여러 위치에서 반복 호출하여 사용 가능
  - 이를 통해 중복 코드를 사용하지 않아 코드 유지 관리를 단순화할 수 있음
  
- 모듈화(Modularity)
  - 복잡한 문제를 작고 관리하기 쉬운 단위로 분리하여, 각 함수는 하나의 특정 작업에 집중
  - 이를 통해 코드 베이스를 이해하기 쉽게 만들고, 팀원이 각자 독립적인 함수를 개발했다 나중에 합칠 수 있는 협업을 용이하게 함
  
- 추상화 (Abstraction)
  - 복잡한 내부 로직을 숨기고 단순한 인터페이스를 제공함
  - 이를 통해 사용자가 내부 구현의 세부 사항을 신경쓰지 않아도 함수를 활용 가능하고, 내부 구현을 변경해도 함수의 외부 사용 방식은 유지 가능
  
- 스코프 및 캡슐화 (Scope and Encapsulation)
  - 함수 내부에서 선언된 지역 변수는 해당 함수 블록에서만 유효하고, 함수 종료 시 메모리에서 사라짐
  - 이를 통해 다른 함수에서 동일한 변수명을 사용해도 충돌이 발생하지 않음
  - 캡슐화를 하여 데이터가 함수 외부로 무분별하게 노출되는 것을 방지
  
- (C# 함수의 경우)타입 안전성 (Type Safety) : C#에서 함수는 매개변수와 반환값의 타입을 명확히 지정하기 때문에 잘못된 자료형의 데이터가 전달되어 발생하는 오류를 방지할 수 있음



## D. 함수를 사용하는 이유
- 코드 재사용성을 통한 중복 코드 제거가 가능함
- 프로그램이 복잡해질수록 전체 코드를 이해하기 어려워지는데, 함수를 사용하면 코드를 논리적인 단위(모듈)로 분리하여 해당 함수만 수정하는 유지보수를 하면 되어서, 코드 관리와 유지보수가 용이함
- 프로그램 코드를 읽을 때 함수 명칭만 보고도 어떤 흐름인지 예측 가능하여 가독성 및 코드 이해도가 향상됨
- 각 함수가 독립적으로 작업을 수행하기에, 문제가 발생했을 때 디버깅을 하면 어느 부분에서 오류가 발생하였는지 추적하기 쉬움
- 각각 함수가 독립적이기에 협업 시 역할 분담이 명확해지고, 독립적이면서 병렬로 개발이 가능하여 협업 효율성 증대



## E. 함수의 기본 구조 및 구성 요소
- 함수의 기본 구조
```csharp
접근_지정자 반환_타입 함수_이름(매개변수_타입 매개변수_이름, ...)
{
    // 함수_본문 (실행될 코드)
    // 필요할 시 return 문 사용
}
```
- 접근 지정자 (Access Modifier)
  - 함수의 접근 범위를 지정함
  - `public`, `private`, `protected` 등
  
- 반환 타입 (Return Type)
  - 함수 실행 후 반환하는 값의 데이터 타입 지정
  - 반환값은 기본적으로 1개만 가질 수 있음
  - 복수의 반환값을 가지기 위해선 매개변수 한정자 중 out 키워드를 사용해야 함
  - 반환값(리턴값)이 없으면 `void` 사용
  
- 함수 이름 (Method Name) : 함수를 호출할 때 사용하는 고유한 명칭

- 매개변수 (Parameters, 인자값)
  - 함수가 호출될 때 전달받는 외부의 값
  - 매개변수 타입과 이름은 여러 개가 될 수 있음, 이 경우 ','로 구분 (실제로는 가독성 이슈가 있어서 많이 넣지는 않음)
  - 매개변수가 없는 함수라도 '()'는 필요함
  
- 함수_본문 (Method Body) : 중괄호({}) 안에 실제 수행될 코드
  - 객체 지향 프로그래밍의 관점에서 한 함수는 한 가지 기능만 넣는 것이 좋음 (단일 책임, SRP)



## F. 함수의 형태
- 함수의 형태는 4가지가 있음
  - 반환값과 매개변수가 모두 없는 형태의 함수
  - 반환값은 없고, 매개변수는 있는 형태의 함수
  - 반환값이 있고, 매개변수는 없는 형태의 함수
  - 반환값과 매개변수가 모두 있는 형태의 함수

- 반환값 X, 매개변수 X 형태의 함수 예시
  ```csharp
  // 콘솔창에 '게임 오버' 문구를 출력하여,
  // 해당 기능이 잘 작동하는지 개발자가 직관적으로 확인할 수 있도록 돕는 함수
  public void PrintGameOver() 
  {
      // 콘솔에 '게임 오버' 문구를 출력할 코드
  }
  ```

- 반환값 X, 매개변수 O 형태의 함수 예시
  ```csharp
  // 유저 로그인 시, 해당 유저의 이름을 받아 콘솔에 알리는 함수
  public void PrintUserAccess(string userName)
  {
      // 해당 유저가 접속했음을 콘솔에 알리는 코드
  }
  ```

- 반환값 O, 매개변수 X 형태의 함수 예시
  ```csharp
  // 현재 년도를 찾아서 반환하는 함수
  public int GetCurrentYear() 
  {
      int thisYear;
      // 현재 날짜를 찾아서, 년도만 int 값으로 변환하는 코드
      return thisYear;
  }
  ```

- 반환값 O, 매개변수 O 형태의 함수 예시
  ```csharp
  // 공격자의 최종 피해량과방어자의 최종 방어 수치를 받아 최종 피해량을 계산해 결과를 반환하는 함수
  public float FinalDamageTotal(float attackerFinalDamage, float defencerFinalDefence)
  {
      float finalDamage;
      // 최종 피해량을 계산하는 코드
      return finalDamage;
  }
  ```


## G. 매개변수 한정자
- 함수에서 매개변수를 전달하는 방식을 지정하는 키워드
- C#에서 매개변수 한정자는 ref, out, in params 등이 있음
- **ref**
  - 매개변수를 참조로 전달하여, 함수 내에서 값을 수정할 수 있도록 함
  - 읽기와 쓰기가 모두 가능함
  - 호출하기 전에 변수를 초기화해야 함
  ```csharp
  public void GetPlayerData(out int CharTempID, out int Level)
  {
    // 캐릭터 임시 ID와 레벨의 값을 할당하는 코드
  }
  ```
  
- **out**
  - 매개변수를 참조로 전달하고 함수 내에서 반드시 값을 할당해야 함
  - 초기화되지 않은 변수를 함수에 전달하고 여러 값을 반환하는 데 사용
  - 쓰기가 가능함
  - out 키워드가 붙은 인자에는 **반드시 값 할당** 필요 (반드시 return으로 보내줘야 함)
  ```csharp
  public void AddNumber(ref int number)
  {
    // number 관련 연산 코드
  }
  ```

- **in**
  - 매개변수를 `읽기 전용` 상태의 참조로 전달
  - 함수 내에서 값을 수정할 수 없음
  ```csharp
  int number = 10;
  public void FunctionNumber(in int number)
  {
    // number 관련 연산 코드
  }
  ```

- **params**
  - 개수가 가변적인 인수를 함수에 전달할 때 사용
  ```csharp
  public void CollectingNumber(params int[] numbers)
  {
    // 받은 숫자들을 제어하는 코드
  }
  ```



## H. 함수와 메서드
- 함수(Function)와 메서드(Method)는 프로그래밍에서 특정 작업을 수행하는 코드 블록
- 그러나 둘은 사용하는 언어의 패러다임(문제를 해결하고 코드를 구성하는 관점과 방법론)과 정의되는 방식에서 차이가 있음
  - 주요 프로그래밍 패러다임의 예시
    - 명령형 프로그래밍 : 프로그램을 일련의 명령어들로 보고, 컴퓨터에게 '어떻게' 동작해야 하는지 단계별로 명령하는 방식
    - 객체 지향 프로그래밍(OOP) : 데이터와 기능을 '객체'라는 단위로 묶어, 객체 간의 상호작용으로 프로그램을 구현하는 방식
    - 함수형 프로그래밍 :  불변하는 데이터와 상태를 최소화하고, 부작용 없는 순수 함수(다른 변수나 입출력을 직접 변경하지 않고, 입력값에만 기반해 결과값을 반환)를 조합하여 문제를 해결하는 프로그래밍 방식

- **(좁은 의미의)함수**
  - 정의 : 클래스나 객체에 독립적으로 존재하고, 특정 작업을 수행하는 독립적인 코드 블록
  - 특징
    - 데이터와 분리되어 독립적으로 호출
  - `main` 함수 등 프로그램의 진입점 역할도 가능함
  - 사용 방식 : 절차적 프로그래밍 / 함수형 프로그래밍 언어에서 핵심 개념으로 사용
  - 사용 언어 : C, Pascal 등

- **메서드**
  - 정의 : 객체 지향 프로그래밍에서 클래스(Class) / 객체(Object) 내부에 속하고 정의되는 함수, 해당 객체 상태(데이터)에 접근하고 조작 가능
  - 특징
    - 항상 특정 객체 / 클래스에 소속됨
    - 메서드는 자신이 속한 객체의 데이터를 사용해 작업을 수행하고, 객체의 상태 변경 가능
    - `this` / `self`와 같은 키워드를 통해 자신의 객체 인스턴스(클래스를 바탕으로 실제 생성된 구체적인 객체)에 접근함
  - 사용 방식 : 주로 객체 지향 프로그래밍 언어에서 핵심 개념으로 사용
  - 사용 언어 : C#, Java, C++, Ruby 등



static 키워드 붙은 것에 사용할 때는 static 필요
지역변수 전역변수 
void를 사용한 함수는 반환값이 생기지 않음


매개변수 한정자
  in - 
    foreach()
  out - 함수의 반환값과 별개로 인자 값을 외부로 건네주고 싶을 때 사용하는 키워드
    Try.Parse(temp out result); 도 반환형은 bool 타입인데, 결과 값도 내야 하니 out 사용
  ref - 

call by ref - 주소를 복사해 사용하기에 데이터 수정 시 원래 함수의 인자값이 변함
call by val - 값을 복사해 사용하기에 데이터 수정 시 원래 함수의 인자값은 변하지 않음

ref 로 접근하기 위해선 인자값 뿐만 아니라 함수 사용 시에도 ref 값을 변수 앞에 붙여줘야 함


함수 명 지을 때는 단순히 지으면 라이브러리에 있는 함수와 동일하거나 비슷한 이름일 수 있어서, 좀더 길고 기능에 직관적인 이름 필요


함수 내에서 사용한 매개변수는 함수 호출시 메모리에 공간이 생성되고, 함수 기능이 끝날 시({} 안의 기능 다 작동 후) 소멸





조금 이해가 어려우신 분들을 위해서 학습키워드 던져드리겠습니다.



1. 메모리 구조(Memory Structure) 4가지 반드시 학습 (코드, 데이터, 힙, 스택), 변수가 들고 있는게 값인지 주소인지
2. 값타입이란? 참조 타입이란? 둘의 차이는? 값 복사와 주소 복사 개념 확립
3. 배열 참조 타입의 실제 동작을 관찰?
4. ref, out 키워드 사용법 익히기, 원본을 직접 수정한다는 개념 자연스럽게 연결


배열은 참조 타입이라 ref, out 등 매개변수 한정자 없어도(값 타입으로 넘겨줘도) 함수에서 값이 바뀌면 원본의 값이 바뀜


디버거 & 주소값



## 내일 수업 전까지 미리 보기
1. V 함수 교안에서 함수 단위 Visual Studio 디버깅
2. 디버거 교안 전체











값(Value) 타입 원본 데이터	&	Call by Value 로 넘기기	->	원본 데이터 수정 안 됨
값(Value) 타입 원본 데이터	&	Call by Reference 로 넘기기	->	원본 데이터 수정 됨
참조(Reference) 타입 원본 데이터	&	Call by Value 로 넘기기	->	원본 데이터 수정 됨
참조(Reference) 타입 원본 데이터	&	Call by Reference 로 넘기기	->	원본 데이터 수정 됨

이렇게 되면 혹시 참조 타입 원본 데이터를 넘기는데,
반대로 원본 데이터 수정 안 되도록 만들어주려면 수업 중에 나왔던 String에 사용한 `Immutable` 키워드를 사용할까요??

예를 들어, 캐릭터 ID(예 : HeroSSR0101, MonsterElite0101) 처럼 string을 써서 만들었는데,
내부 정보를 불러오기 위해 ID를 참조하지만, 그 값은 바꾸면 위험한 자료는 수정을 막을 것 같아서요.

in, foreach

c#에 immutable 이라는 키워드는 없습니다.
대신 필드를 readonly로 선언하거나 프로퍼티로 setter를 금지시키는 방식이 있습니다. 원본 값을 변경하지 못하도록 막는거죠.

System.Collections.Immutable 은 API 이고 키워드는 아니인듯


----------------

값(Value) 타입 데이터와 참조(Reference) 타입 데이터를 Call by Value로 넘기는 것을 제대로 이해 한 것인지 여쭙고 싶습니다.

예를 들어, int 타입 데이터 1000개를 Call by Value 로 넘기면 스택 메모리에 순식간에 4 * 1000 바이트 의 메모리 공간이 추가로 생겨야 하고, 
int[] (int 배열)을 생성하고 [1000] (1000개 공간)을 Call by Value 로 넘기면 int[] (배열)의 맨 앞줄 주소 값(윈도우 64 bit 환경에서 8 바이트(64 비트)) 에 해당하는 메모리 공간이 스택 메모리에 새로 생기는 것이 맞을까요?

만약 맞다면, 대규모의 데이터는 값 타입 보단 배열 등 참조 타입으로 생성하는 것이 메모리 성능 상에 큰 이점이 될까요?